{"ast":null,"code":"/** @license React v0.15.0\r\n * scheduler.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    var enableSchedulerDebugging = false;\n    var enableIsInputPending = false;\n    var requestIdleCallbackBeforeFirstFrame = false;\n    var requestTimerEventBeforeFirstFrame = false;\n    var enableMessageLoopImplementation = false;\n\n    // The DOM Scheduler implementation is similar to requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    var requestHostCallback = void 0;\n    var requestHostTimeout = void 0;\n    var cancelHostTimeout = void 0;\n    var shouldYieldToHost = void 0;\n    var requestPaint = void 0;\n    exports.unstable_now = void 0;\n    exports.unstable_forceFrameRate = void 0;\n    if (\n    // If Scheduler runs in a non-DOM environment, it falls back to a naive\n    // implementation using setTimeout.\n    typeof window === 'undefined' ||\n    // Check if MessageChannel is supported, too.\n    typeof MessageChannel !== 'function') {\n      // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n      // fallback to a naive implementation.\n      var _callback = null;\n      var _timeoutID = null;\n      var _flushCallback = function () {\n        if (_callback !== null) {\n          try {\n            var currentTime = exports.unstable_now();\n            var hasRemainingTime = true;\n            _callback(hasRemainingTime, currentTime);\n            _callback = null;\n          } catch (e) {\n            setTimeout(_flushCallback, 0);\n            throw e;\n          }\n        }\n      };\n      exports.unstable_now = function () {\n        return Date.now();\n      };\n      requestHostCallback = function (cb) {\n        if (_callback !== null) {\n          // Protect against re-entrancy.\n          setTimeout(requestHostCallback, 0, cb);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, 0);\n        }\n      };\n      requestHostTimeout = function (cb, ms) {\n        _timeoutID = setTimeout(cb, ms);\n      };\n      cancelHostTimeout = function () {\n        clearTimeout(_timeoutID);\n      };\n      shouldYieldToHost = function () {\n        return false;\n      };\n      requestPaint = exports.unstable_forceFrameRate = function () {};\n    } else {\n      // Capture local references to native APIs, in case a polyfill overrides them.\n      var performance = window.performance;\n      var _Date = window.Date;\n      var _setTimeout = window.setTimeout;\n      var _clearTimeout = window.clearTimeout;\n      var requestAnimationFrame = window.requestAnimationFrame;\n      var cancelAnimationFrame = window.cancelAnimationFrame;\n      var requestIdleCallback = window.requestIdleCallback;\n      if (typeof console !== 'undefined') {\n        // TODO: Remove fb.me link\n        if (typeof requestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n        if (typeof cancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n      var requestIdleCallbackBeforeFirstFrame$1 = requestIdleCallbackBeforeFirstFrame && typeof requestIdleCallback === 'function' && typeof cancelIdleCallback === 'function';\n      exports.unstable_now = typeof performance === 'object' && typeof performance.now === 'function' ? function () {\n        return performance.now();\n      } : function () {\n        return _Date.now();\n      };\n      var isRAFLoopRunning = false;\n      var isMessageLoopRunning = false;\n      var scheduledHostCallback = null;\n      var rAFTimeoutID = -1;\n      var taskTimeoutID = -1;\n      var frameLength = enableMessageLoopImplementation ?\n      // We won't attempt to align with the vsync. Instead we'll yield multiple\n      // times per frame, often enough to keep it responsive even at really\n      // high frame rates > 120.\n      5 :\n      // Use a heuristic to measure the frame rate and yield at the end of the\n      // frame. We start out assuming that we run at 30fps but then the\n      // heuristic tracking will adjust this value to a faster fps if we get\n      // more frequent animation frames.\n      33.33;\n      var prevRAFTime = -1;\n      var prevRAFInterval = -1;\n      var frameDeadline = 0;\n      var fpsLocked = false;\n\n      // TODO: Make this configurable\n      // TODO: Adjust this based on priority?\n      var maxFrameLength = 300;\n      var needsPaint = false;\n      if (enableIsInputPending && navigator !== undefined && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined) {\n        var scheduling = navigator.scheduling;\n        shouldYieldToHost = function () {\n          var currentTime = exports.unstable_now();\n          if (currentTime >= frameDeadline) {\n            // There's no time left in the frame. We may want to yield control of\n            // the main thread, so the browser can perform high priority tasks. The\n            // main ones are painting and user input. If there's a pending paint or\n            // a pending input, then we should yield. But if there's neither, then\n            // we can yield less often while remaining responsive. We'll eventually\n            // yield regardless, since there could be a pending paint that wasn't\n            // accompanied by a call to `requestPaint`, or other main thread tasks\n            // like network events.\n            if (needsPaint || scheduling.isInputPending()) {\n              // There is either a pending paint or a pending input.\n              return true;\n            }\n            // There's no pending input. Only yield if we've reached the max\n            // frame length.\n            return currentTime >= frameDeadline + maxFrameLength;\n          } else {\n            // There's still time left in the frame.\n            return false;\n          }\n        };\n        requestPaint = function () {\n          needsPaint = true;\n        };\n      } else {\n        // `isInputPending` is not available. Since we have no way of knowing if\n        // there's pending input, always yield at the end of the frame.\n        shouldYieldToHost = function () {\n          return exports.unstable_now() >= frameDeadline;\n        };\n\n        // Since we yield every frame regardless, `requestPaint` has no effect.\n        requestPaint = function () {};\n      }\n      exports.unstable_forceFrameRate = function (fps) {\n        if (fps < 0 || fps > 125) {\n          console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');\n          return;\n        }\n        if (fps > 0) {\n          frameLength = Math.floor(1000 / fps);\n          fpsLocked = true;\n        } else {\n          // reset the framerate\n          frameLength = 33.33;\n          fpsLocked = false;\n        }\n      };\n      var performWorkUntilDeadline = function () {\n        if (enableMessageLoopImplementation) {\n          if (scheduledHostCallback !== null) {\n            var currentTime = exports.unstable_now();\n            // Yield after `frameLength` ms, regardless of where we are in the vsync\n            // cycle. This means there's always time remaining at the beginning of\n            // the message event.\n            frameDeadline = currentTime + frameLength;\n            var hasTimeRemaining = true;\n            try {\n              var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n              if (!hasMoreWork) {\n                isMessageLoopRunning = false;\n                scheduledHostCallback = null;\n              } else {\n                // If there's more work, schedule the next message event at the end\n                // of the preceding one.\n                port.postMessage(null);\n              }\n            } catch (error) {\n              // If a scheduler task throws, exit the current browser task so the\n              // error can be observed.\n              port.postMessage(null);\n              throw error;\n            }\n          }\n          // Yielding to the browser will give it a chance to paint, so we can\n          // reset this.\n          needsPaint = false;\n        } else {\n          if (scheduledHostCallback !== null) {\n            var _currentTime = exports.unstable_now();\n            var _hasTimeRemaining = frameDeadline - _currentTime > 0;\n            try {\n              var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);\n              if (!_hasMoreWork) {\n                scheduledHostCallback = null;\n              }\n            } catch (error) {\n              // If a scheduler task throws, exit the current browser task so the\n              // error can be observed, and post a new task as soon as possible\n              // so we can continue where we left off.\n              port.postMessage(null);\n              throw error;\n            }\n          }\n          // Yielding to the browser will give it a chance to paint, so we can\n          // reset this.\n          needsPaint = false;\n        }\n      };\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      var onAnimationFrame = function (rAFTime) {\n        if (scheduledHostCallback === null) {\n          // No scheduled work. Exit.\n          prevRAFTime = -1;\n          prevRAFInterval = -1;\n          isRAFLoopRunning = false;\n          return;\n        }\n\n        // Eagerly schedule the next animation callback at the beginning of the\n        // frame. If the scheduler queue is not empty at the end of the frame, it\n        // will continue flushing inside that callback. If the queue *is* empty,\n        // then it will exit immediately. Posting the callback at the start of the\n        // frame ensures it's fired within the earliest possible frame. If we\n        // waited until the end of the frame to post the callback, we risk the\n        // browser skipping a frame and not firing the callback until the frame\n        // after that.\n        isRAFLoopRunning = true;\n        requestAnimationFrame(function (nextRAFTime) {\n          _clearTimeout(rAFTimeoutID);\n          onAnimationFrame(nextRAFTime);\n        });\n\n        // requestAnimationFrame is throttled when the tab is backgrounded. We\n        // don't want to stop working entirely. So we'll fallback to a timeout loop.\n        // TODO: Need a better heuristic for backgrounded work.\n        var onTimeout = function () {\n          frameDeadline = exports.unstable_now() + frameLength / 2;\n          performWorkUntilDeadline();\n          rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n        };\n        rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n        if (prevRAFTime !== -1 &&\n        // Make sure this rAF time is different from the previous one. This check\n        // could fail if two rAFs fire in the same frame.\n        rAFTime - prevRAFTime > 0.1) {\n          var rAFInterval = rAFTime - prevRAFTime;\n          if (!fpsLocked && prevRAFInterval !== -1) {\n            // We've observed two consecutive frame intervals. We'll use this to\n            // dynamically adjust the frame rate.\n            //\n            // If one frame goes long, then the next one can be short to catch up.\n            // If two frames are short in a row, then that's an indication that we\n            // actually have a higher frame rate than what we're currently\n            // optimizing. For example, if we're running on 120hz display or 90hz VR\n            // display. Take the max of the two in case one of them was an anomaly\n            // due to missed frame deadlines.\n            if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\n              frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\n              if (frameLength < 8.33) {\n                // Defensive coding. We don't support higher frame rates than 120hz.\n                // If the calculated frame length gets lower than 8, it is probably\n                // a bug.\n                frameLength = 8.33;\n              }\n            }\n          }\n          prevRAFInterval = rAFInterval;\n        }\n        prevRAFTime = rAFTime;\n        frameDeadline = rAFTime + frameLength;\n\n        // We use the postMessage trick to defer idle work until after the repaint.\n        port.postMessage(null);\n      };\n      requestHostCallback = function (callback) {\n        scheduledHostCallback = callback;\n        if (enableMessageLoopImplementation) {\n          if (!isMessageLoopRunning) {\n            isMessageLoopRunning = true;\n            port.postMessage(null);\n          }\n        } else {\n          if (!isRAFLoopRunning) {\n            // Start a rAF loop.\n            isRAFLoopRunning = true;\n            requestAnimationFrame(function (rAFTime) {\n              if (requestIdleCallbackBeforeFirstFrame$1) {\n                cancelIdleCallback(idleCallbackID);\n              }\n              if (requestTimerEventBeforeFirstFrame) {\n                _clearTimeout(idleTimeoutID);\n              }\n              onAnimationFrame(rAFTime);\n            });\n\n            // If we just missed the last vsync, the next rAF might not happen for\n            // another frame. To claim as much idle time as possible, post a\n            // callback with `requestIdleCallback`, which should fire if there's\n            // idle time left in the frame.\n            //\n            // This should only be an issue for the first rAF in the loop;\n            // subsequent rAFs are scheduled at the beginning of the\n            // preceding frame.\n            var idleCallbackID = void 0;\n            if (requestIdleCallbackBeforeFirstFrame$1) {\n              idleCallbackID = requestIdleCallback(function onIdleCallbackBeforeFirstFrame() {\n                if (requestTimerEventBeforeFirstFrame) {\n                  _clearTimeout(idleTimeoutID);\n                }\n                frameDeadline = exports.unstable_now() + frameLength;\n                performWorkUntilDeadline();\n              });\n            }\n            // Alternate strategy to address the same problem. Scheduler a timer\n            // with no delay. If this fires before the rAF, that likely indicates\n            // that there's idle time before the next vsync. This isn't always the\n            // case, but we'll be aggressive and assume it is, as a trade off to\n            // prevent idle periods.\n            var idleTimeoutID = void 0;\n            if (requestTimerEventBeforeFirstFrame) {\n              idleTimeoutID = _setTimeout(function onTimerEventBeforeFirstFrame() {\n                if (requestIdleCallbackBeforeFirstFrame$1) {\n                  cancelIdleCallback(idleCallbackID);\n                }\n                frameDeadline = exports.unstable_now() + frameLength;\n                performWorkUntilDeadline();\n              }, 0);\n            }\n          }\n        }\n      };\n      requestHostTimeout = function (callback, ms) {\n        taskTimeoutID = _setTimeout(function () {\n          callback(exports.unstable_now());\n        }, ms);\n      };\n      cancelHostTimeout = function () {\n        _clearTimeout(taskTimeoutID);\n        taskTimeoutID = -1;\n      };\n    }\n\n    /* eslint-disable no-var */\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n\n    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n    var maxSigned31BitInt = 1073741823;\n\n    // Times out immediately\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n    // Eventually times out\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000;\n    // Never times out\n    var IDLE_PRIORITY = maxSigned31BitInt;\n\n    // Tasks are stored as a circular, doubly linked list.\n    var firstTask = null;\n    var firstDelayedTask = null;\n\n    // Pausing the scheduler is useful for debugging.\n    var isSchedulerPaused = false;\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority;\n\n    // This is set while performing work, to prevent re-entrancy.\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false;\n    function scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function flushTask(task, currentTime) {\n      // Remove the task from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = task.next;\n      if (next === task) {\n        // This is the only scheduled task. Clear the list.\n        firstTask = null;\n      } else {\n        // Remove the task from its position in the list.\n        if (task === firstTask) {\n          firstTask = next;\n        }\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      task.next = task.previous = null;\n\n      // Now it's safe to execute the task.\n      var callback = task.callback;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousTask = currentTask;\n      currentPriorityLevel = task.priorityLevel;\n      currentTask = task;\n      var continuationCallback;\n      try {\n        var didUserCallbackTimeout = task.expirationTime <= currentTime;\n        // Add an extra function to the callstack. Profiling tools can use this\n        // to infer the priority of work that appears higher in the stack.\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\n            break;\n          case UserBlockingPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\n            break;\n          case NormalPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\n            break;\n          case LowPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\n            break;\n          case IdlePriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\n            break;\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentTask = previousTask;\n      }\n\n      // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n      if (typeof continuationCallback === 'function') {\n        var expirationTime = task.expirationTime;\n        var continuationTask = task;\n        continuationTask.callback = continuationCallback;\n\n        // Insert the new callback into the list, sorted by its timeout. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal timeout instead\n        // of after.\n        if (firstTask === null) {\n          // This is the first callback in the list.\n          firstTask = continuationTask.next = continuationTask.previous = continuationTask;\n        } else {\n          var nextAfterContinuation = null;\n          var t = firstTask;\n          do {\n            if (expirationTime <= t.expirationTime) {\n              // This task times out at or after the continuation. We will insert\n              // the continuation *before* this task.\n              nextAfterContinuation = t;\n              break;\n            }\n            t = t.next;\n          } while (t !== firstTask);\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority task was found, which means the new task\n            // is the lowest priority task in the list.\n            nextAfterContinuation = firstTask;\n          } else if (nextAfterContinuation === firstTask) {\n            // The new task is the highest priority task in the list.\n            firstTask = continuationTask;\n          }\n          var _previous = nextAfterContinuation.previous;\n          _previous.next = nextAfterContinuation.previous = continuationTask;\n          continuationTask.next = nextAfterContinuation;\n          continuationTask.previous = _previous;\n        }\n      }\n    }\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\n        do {\n          var task = firstDelayedTask;\n          var next = task.next;\n          if (task === next) {\n            firstDelayedTask = null;\n          } else {\n            firstDelayedTask = next;\n            var previous = task.previous;\n            previous.next = next;\n            next.previous = previous;\n          }\n          task.next = task.previous = null;\n          insertScheduledTask(task, task.expirationTime);\n        } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled) {\n        if (firstTask !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else if (firstDelayedTask !== null) {\n          requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n        }\n      }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      // Exit right away if we're currently paused\n      if (enableSchedulerDebugging && isSchedulerPaused) {\n        return;\n      }\n\n      // We'll need a host callback the next time work is scheduled.\n      isHostCallbackScheduled = false;\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      isPerformingWork = true;\n      try {\n        if (!hasTimeRemaining) {\n          // Flush all the expired callbacks without yielding.\n          // TODO: Split flushWork into two separate functions instead of using\n          // a boolean argument?\n          while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\n            flushTask(firstTask, currentTime);\n            currentTime = exports.unstable_now();\n            advanceTimers(currentTime);\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstTask !== null) {\n            do {\n              flushTask(firstTask, currentTime);\n              currentTime = exports.unstable_now();\n              advanceTimers(currentTime);\n            } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\n          }\n        }\n        // Return whether there's additional work\n        if (firstTask !== null) {\n          return true;\n        } else {\n          if (firstDelayedTask !== null) {\n            requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n          }\n          return false;\n        }\n      } finally {\n        isPerformingWork = false;\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n    function timeoutForPriorityLevel(priorityLevel) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          return IMMEDIATE_PRIORITY_TIMEOUT;\n        case UserBlockingPriority:\n          return USER_BLOCKING_PRIORITY;\n        case IdlePriority:\n          return IDLE_PRIORITY;\n        case LowPriority:\n          return LOW_PRIORITY_TIMEOUT;\n        case NormalPriority:\n        default:\n          return NORMAL_PRIORITY_TIMEOUT;\n      }\n    }\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      var timeout;\n      if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n        timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n      } else {\n        timeout = timeoutForPriorityLevel(priorityLevel);\n        startTime = currentTime;\n      }\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      };\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        insertDelayedTask(newTask, startTime);\n        if (firstTask === null && firstDelayedTask === newTask) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          }\n          // Schedule a timeout.\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        insertScheduledTask(newTask, expirationTime);\n        // Schedule a host callback, if needed. If we're already performing work,\n        // wait until the next time we yield.\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      return newTask;\n    }\n    function insertScheduledTask(newTask, expirationTime) {\n      // Insert the new task into the list, ordered first by its timeout, then by\n      // insertion. So the new task is inserted after any other task the\n      // same timeout\n      if (firstTask === null) {\n        // This is the first task in the list.\n        firstTask = newTask.next = newTask.previous = newTask;\n      } else {\n        var next = null;\n        var task = firstTask;\n        do {\n          if (expirationTime < task.expirationTime) {\n            // The new task times out before this one.\n            next = task;\n            break;\n          }\n          task = task.next;\n        } while (task !== firstTask);\n        if (next === null) {\n          // No task with a later timeout was found, which means the new task has\n          // the latest timeout in the list.\n          next = firstTask;\n        } else if (next === firstTask) {\n          // The new task has the earliest expiration in the entire list.\n          firstTask = newTask;\n        }\n        var previous = next.previous;\n        previous.next = next.previous = newTask;\n        newTask.next = next;\n        newTask.previous = previous;\n      }\n    }\n    function insertDelayedTask(newTask, startTime) {\n      // Insert the new task into the list, ordered by its start time.\n      if (firstDelayedTask === null) {\n        // This is the first task in the list.\n        firstDelayedTask = newTask.next = newTask.previous = newTask;\n      } else {\n        var next = null;\n        var task = firstDelayedTask;\n        do {\n          if (startTime < task.startTime) {\n            // The new task times out before this one.\n            next = task;\n            break;\n          }\n          task = task.next;\n        } while (task !== firstDelayedTask);\n        if (next === null) {\n          // No task with a later timeout was found, which means the new task has\n          // the latest timeout in the list.\n          next = firstDelayedTask;\n        } else if (next === firstDelayedTask) {\n          // The new task has the earliest expiration in the entire list.\n          firstDelayedTask = newTask;\n        }\n        var previous = next.previous;\n        previous.next = next.previous = newTask;\n        newTask.next = next;\n        newTask.previous = previous;\n      }\n    }\n    function unstable_pauseExecution() {\n      isSchedulerPaused = true;\n    }\n    function unstable_continueExecution() {\n      isSchedulerPaused = false;\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n    function unstable_getFirstCallbackNode() {\n      return firstTask;\n    }\n    function unstable_cancelCallback(task) {\n      var next = task.next;\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n      if (task === next) {\n        if (task === firstTask) {\n          firstTask = null;\n        } else if (task === firstDelayedTask) {\n          firstDelayedTask = null;\n        }\n      } else {\n        if (task === firstTask) {\n          firstTask = next;\n        } else if (task === firstDelayedTask) {\n          firstDelayedTask = next;\n        }\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      task.next = task.previous = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    function unstable_shouldYield() {\n      var currentTime = exports.unstable_now();\n      advanceTimers(currentTime);\n      return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n    }\n    var unstable_requestPaint = requestPaint;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_next = unstable_next;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","enableSchedulerDebugging","enableIsInputPending","requestIdleCallbackBeforeFirstFrame","requestTimerEventBeforeFirstFrame","enableMessageLoopImplementation","requestHostCallback","requestHostTimeout","cancelHostTimeout","shouldYieldToHost","requestPaint","unstable_now","unstable_forceFrameRate","window","MessageChannel","_callback","_timeoutID","_flushCallback","currentTime","hasRemainingTime","e","setTimeout","Date","now","cb","ms","clearTimeout","performance","_Date","_setTimeout","_clearTimeout","requestAnimationFrame","cancelAnimationFrame","requestIdleCallback","console","error","requestIdleCallbackBeforeFirstFrame$1","cancelIdleCallback","isRAFLoopRunning","isMessageLoopRunning","scheduledHostCallback","rAFTimeoutID","taskTimeoutID","frameLength","prevRAFTime","prevRAFInterval","frameDeadline","fpsLocked","maxFrameLength","needsPaint","navigator","undefined","scheduling","isInputPending","fps","Math","floor","performWorkUntilDeadline","hasTimeRemaining","hasMoreWork","port","postMessage","_currentTime","_hasTimeRemaining","_hasMoreWork","channel","port2","port1","onmessage","onAnimationFrame","rAFTime","nextRAFTime","onTimeout","rAFInterval","callback","idleCallbackID","idleTimeoutID","onIdleCallbackBeforeFirstFrame","onTimerEventBeforeFirstFrame","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstTask","firstDelayedTask","isSchedulerPaused","currentTask","currentPriorityLevel","isPerformingWork","isHostCallbackScheduled","isHostTimeoutScheduled","scheduler_flushTaskAtPriority_Immediate","didTimeout","scheduler_flushTaskAtPriority_UserBlocking","scheduler_flushTaskAtPriority_Normal","scheduler_flushTaskAtPriority_Low","scheduler_flushTaskAtPriority_Idle","flushTask","task","next","previous","previousPriorityLevel","previousTask","priorityLevel","continuationCallback","didUserCallbackTimeout","expirationTime","continuationTask","nextAfterContinuation","t","_previous","advanceTimers","startTime","insertScheduledTask","handleTimeout","flushWork","initialTime","unstable_runWithPriority","eventHandler","unstable_next","unstable_wrapCallback","parentPriorityLevel","apply","arguments","timeoutForPriorityLevel","unstable_scheduleCallback","options","timeout","delay","newTask","insertDelayedTask","unstable_pauseExecution","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_cancelCallback","unstable_getCurrentPriorityLevel","unstable_shouldYield","unstable_requestPaint","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority"],"sources":["C:/Users/jamie/Desktop/CA2/NODEJS-ONLY/client/node_modules/scheduler/cjs/scheduler.development.js"],"sourcesContent":["/** @license React v0.15.0\r\n * scheduler.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\n\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar enableSchedulerDebugging = false;\r\nvar enableIsInputPending = false;\r\nvar requestIdleCallbackBeforeFirstFrame = false;\r\nvar requestTimerEventBeforeFirstFrame = false;\r\nvar enableMessageLoopImplementation = false;\r\n\r\n// The DOM Scheduler implementation is similar to requestIdleCallback. It\r\n// works by scheduling a requestAnimationFrame, storing the time for the start\r\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\r\n// Within the postMessage handler do as much work as possible until time + frame\r\n// rate. By separating the idle call into a separate event tick we ensure that\r\n// layout, paint and other browser work is counted against the available time.\r\n// The frame rate is dynamically adjusted.\r\n\r\nvar requestHostCallback = void 0;\r\n\r\nvar requestHostTimeout = void 0;\r\nvar cancelHostTimeout = void 0;\r\nvar shouldYieldToHost = void 0;\r\nvar requestPaint = void 0;\r\nexports.unstable_now = void 0;\r\nexports.unstable_forceFrameRate = void 0;\r\n\r\nif (\r\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\r\n// implementation using setTimeout.\r\ntypeof window === 'undefined' ||\r\n// Check if MessageChannel is supported, too.\r\ntypeof MessageChannel !== 'function') {\r\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\r\n  // fallback to a naive implementation.\r\n  var _callback = null;\r\n  var _timeoutID = null;\r\n  var _flushCallback = function () {\r\n    if (_callback !== null) {\r\n      try {\r\n        var currentTime = exports.unstable_now();\r\n        var hasRemainingTime = true;\r\n        _callback(hasRemainingTime, currentTime);\r\n        _callback = null;\r\n      } catch (e) {\r\n        setTimeout(_flushCallback, 0);\r\n        throw e;\r\n      }\r\n    }\r\n  };\r\n  exports.unstable_now = function () {\r\n    return Date.now();\r\n  };\r\n  requestHostCallback = function (cb) {\r\n    if (_callback !== null) {\r\n      // Protect against re-entrancy.\r\n      setTimeout(requestHostCallback, 0, cb);\r\n    } else {\r\n      _callback = cb;\r\n      setTimeout(_flushCallback, 0);\r\n    }\r\n  };\r\n  requestHostTimeout = function (cb, ms) {\r\n    _timeoutID = setTimeout(cb, ms);\r\n  };\r\n  cancelHostTimeout = function () {\r\n    clearTimeout(_timeoutID);\r\n  };\r\n  shouldYieldToHost = function () {\r\n    return false;\r\n  };\r\n  requestPaint = exports.unstable_forceFrameRate = function () {};\r\n} else {\r\n  // Capture local references to native APIs, in case a polyfill overrides them.\r\n  var performance = window.performance;\r\n  var _Date = window.Date;\r\n  var _setTimeout = window.setTimeout;\r\n  var _clearTimeout = window.clearTimeout;\r\n  var requestAnimationFrame = window.requestAnimationFrame;\r\n  var cancelAnimationFrame = window.cancelAnimationFrame;\r\n  var requestIdleCallback = window.requestIdleCallback;\r\n\r\n  if (typeof console !== 'undefined') {\r\n    // TODO: Remove fb.me link\r\n    if (typeof requestAnimationFrame !== 'function') {\r\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\r\n    }\r\n    if (typeof cancelAnimationFrame !== 'function') {\r\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\r\n    }\r\n  }\r\n\r\n  var requestIdleCallbackBeforeFirstFrame$1 = requestIdleCallbackBeforeFirstFrame && typeof requestIdleCallback === 'function' && typeof cancelIdleCallback === 'function';\r\n\r\n  exports.unstable_now = typeof performance === 'object' && typeof performance.now === 'function' ? function () {\r\n    return performance.now();\r\n  } : function () {\r\n    return _Date.now();\r\n  };\r\n\r\n  var isRAFLoopRunning = false;\r\n  var isMessageLoopRunning = false;\r\n  var scheduledHostCallback = null;\r\n  var rAFTimeoutID = -1;\r\n  var taskTimeoutID = -1;\r\n\r\n  var frameLength = enableMessageLoopImplementation ? // We won't attempt to align with the vsync. Instead we'll yield multiple\r\n  // times per frame, often enough to keep it responsive even at really\r\n  // high frame rates > 120.\r\n  5 : // Use a heuristic to measure the frame rate and yield at the end of the\r\n  // frame. We start out assuming that we run at 30fps but then the\r\n  // heuristic tracking will adjust this value to a faster fps if we get\r\n  // more frequent animation frames.\r\n  33.33;\r\n\r\n  var prevRAFTime = -1;\r\n  var prevRAFInterval = -1;\r\n  var frameDeadline = 0;\r\n\r\n  var fpsLocked = false;\r\n\r\n  // TODO: Make this configurable\r\n  // TODO: Adjust this based on priority?\r\n  var maxFrameLength = 300;\r\n  var needsPaint = false;\r\n\r\n  if (enableIsInputPending && navigator !== undefined && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined) {\r\n    var scheduling = navigator.scheduling;\r\n    shouldYieldToHost = function () {\r\n      var currentTime = exports.unstable_now();\r\n      if (currentTime >= frameDeadline) {\r\n        // There's no time left in the frame. We may want to yield control of\r\n        // the main thread, so the browser can perform high priority tasks. The\r\n        // main ones are painting and user input. If there's a pending paint or\r\n        // a pending input, then we should yield. But if there's neither, then\r\n        // we can yield less often while remaining responsive. We'll eventually\r\n        // yield regardless, since there could be a pending paint that wasn't\r\n        // accompanied by a call to `requestPaint`, or other main thread tasks\r\n        // like network events.\r\n        if (needsPaint || scheduling.isInputPending()) {\r\n          // There is either a pending paint or a pending input.\r\n          return true;\r\n        }\r\n        // There's no pending input. Only yield if we've reached the max\r\n        // frame length.\r\n        return currentTime >= frameDeadline + maxFrameLength;\r\n      } else {\r\n        // There's still time left in the frame.\r\n        return false;\r\n      }\r\n    };\r\n\r\n    requestPaint = function () {\r\n      needsPaint = true;\r\n    };\r\n  } else {\r\n    // `isInputPending` is not available. Since we have no way of knowing if\r\n    // there's pending input, always yield at the end of the frame.\r\n    shouldYieldToHost = function () {\r\n      return exports.unstable_now() >= frameDeadline;\r\n    };\r\n\r\n    // Since we yield every frame regardless, `requestPaint` has no effect.\r\n    requestPaint = function () {};\r\n  }\r\n\r\n  exports.unstable_forceFrameRate = function (fps) {\r\n    if (fps < 0 || fps > 125) {\r\n      console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');\r\n      return;\r\n    }\r\n    if (fps > 0) {\r\n      frameLength = Math.floor(1000 / fps);\r\n      fpsLocked = true;\r\n    } else {\r\n      // reset the framerate\r\n      frameLength = 33.33;\r\n      fpsLocked = false;\r\n    }\r\n  };\r\n\r\n  var performWorkUntilDeadline = function () {\r\n    if (enableMessageLoopImplementation) {\r\n      if (scheduledHostCallback !== null) {\r\n        var currentTime = exports.unstable_now();\r\n        // Yield after `frameLength` ms, regardless of where we are in the vsync\r\n        // cycle. This means there's always time remaining at the beginning of\r\n        // the message event.\r\n        frameDeadline = currentTime + frameLength;\r\n        var hasTimeRemaining = true;\r\n        try {\r\n          var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\r\n          if (!hasMoreWork) {\r\n            isMessageLoopRunning = false;\r\n            scheduledHostCallback = null;\r\n          } else {\r\n            // If there's more work, schedule the next message event at the end\r\n            // of the preceding one.\r\n            port.postMessage(null);\r\n          }\r\n        } catch (error) {\r\n          // If a scheduler task throws, exit the current browser task so the\r\n          // error can be observed.\r\n          port.postMessage(null);\r\n          throw error;\r\n        }\r\n      }\r\n      // Yielding to the browser will give it a chance to paint, so we can\r\n      // reset this.\r\n      needsPaint = false;\r\n    } else {\r\n      if (scheduledHostCallback !== null) {\r\n        var _currentTime = exports.unstable_now();\r\n        var _hasTimeRemaining = frameDeadline - _currentTime > 0;\r\n        try {\r\n          var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);\r\n          if (!_hasMoreWork) {\r\n            scheduledHostCallback = null;\r\n          }\r\n        } catch (error) {\r\n          // If a scheduler task throws, exit the current browser task so the\r\n          // error can be observed, and post a new task as soon as possible\r\n          // so we can continue where we left off.\r\n          port.postMessage(null);\r\n          throw error;\r\n        }\r\n      }\r\n      // Yielding to the browser will give it a chance to paint, so we can\r\n      // reset this.\r\n      needsPaint = false;\r\n    }\r\n  };\r\n\r\n  var channel = new MessageChannel();\r\n  var port = channel.port2;\r\n  channel.port1.onmessage = performWorkUntilDeadline;\r\n\r\n  var onAnimationFrame = function (rAFTime) {\r\n    if (scheduledHostCallback === null) {\r\n      // No scheduled work. Exit.\r\n      prevRAFTime = -1;\r\n      prevRAFInterval = -1;\r\n      isRAFLoopRunning = false;\r\n      return;\r\n    }\r\n\r\n    // Eagerly schedule the next animation callback at the beginning of the\r\n    // frame. If the scheduler queue is not empty at the end of the frame, it\r\n    // will continue flushing inside that callback. If the queue *is* empty,\r\n    // then it will exit immediately. Posting the callback at the start of the\r\n    // frame ensures it's fired within the earliest possible frame. If we\r\n    // waited until the end of the frame to post the callback, we risk the\r\n    // browser skipping a frame and not firing the callback until the frame\r\n    // after that.\r\n    isRAFLoopRunning = true;\r\n    requestAnimationFrame(function (nextRAFTime) {\r\n      _clearTimeout(rAFTimeoutID);\r\n      onAnimationFrame(nextRAFTime);\r\n    });\r\n\r\n    // requestAnimationFrame is throttled when the tab is backgrounded. We\r\n    // don't want to stop working entirely. So we'll fallback to a timeout loop.\r\n    // TODO: Need a better heuristic for backgrounded work.\r\n    var onTimeout = function () {\r\n      frameDeadline = exports.unstable_now() + frameLength / 2;\r\n      performWorkUntilDeadline();\r\n      rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\r\n    };\r\n    rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\r\n\r\n    if (prevRAFTime !== -1 &&\r\n    // Make sure this rAF time is different from the previous one. This check\r\n    // could fail if two rAFs fire in the same frame.\r\n    rAFTime - prevRAFTime > 0.1) {\r\n      var rAFInterval = rAFTime - prevRAFTime;\r\n      if (!fpsLocked && prevRAFInterval !== -1) {\r\n        // We've observed two consecutive frame intervals. We'll use this to\r\n        // dynamically adjust the frame rate.\r\n        //\r\n        // If one frame goes long, then the next one can be short to catch up.\r\n        // If two frames are short in a row, then that's an indication that we\r\n        // actually have a higher frame rate than what we're currently\r\n        // optimizing. For example, if we're running on 120hz display or 90hz VR\r\n        // display. Take the max of the two in case one of them was an anomaly\r\n        // due to missed frame deadlines.\r\n        if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\r\n          frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\r\n          if (frameLength < 8.33) {\r\n            // Defensive coding. We don't support higher frame rates than 120hz.\r\n            // If the calculated frame length gets lower than 8, it is probably\r\n            // a bug.\r\n            frameLength = 8.33;\r\n          }\r\n        }\r\n      }\r\n      prevRAFInterval = rAFInterval;\r\n    }\r\n    prevRAFTime = rAFTime;\r\n    frameDeadline = rAFTime + frameLength;\r\n\r\n    // We use the postMessage trick to defer idle work until after the repaint.\r\n    port.postMessage(null);\r\n  };\r\n\r\n  requestHostCallback = function (callback) {\r\n    scheduledHostCallback = callback;\r\n    if (enableMessageLoopImplementation) {\r\n      if (!isMessageLoopRunning) {\r\n        isMessageLoopRunning = true;\r\n        port.postMessage(null);\r\n      }\r\n    } else {\r\n      if (!isRAFLoopRunning) {\r\n        // Start a rAF loop.\r\n        isRAFLoopRunning = true;\r\n        requestAnimationFrame(function (rAFTime) {\r\n          if (requestIdleCallbackBeforeFirstFrame$1) {\r\n            cancelIdleCallback(idleCallbackID);\r\n          }\r\n          if (requestTimerEventBeforeFirstFrame) {\r\n            _clearTimeout(idleTimeoutID);\r\n          }\r\n          onAnimationFrame(rAFTime);\r\n        });\r\n\r\n        // If we just missed the last vsync, the next rAF might not happen for\r\n        // another frame. To claim as much idle time as possible, post a\r\n        // callback with `requestIdleCallback`, which should fire if there's\r\n        // idle time left in the frame.\r\n        //\r\n        // This should only be an issue for the first rAF in the loop;\r\n        // subsequent rAFs are scheduled at the beginning of the\r\n        // preceding frame.\r\n        var idleCallbackID = void 0;\r\n        if (requestIdleCallbackBeforeFirstFrame$1) {\r\n          idleCallbackID = requestIdleCallback(function onIdleCallbackBeforeFirstFrame() {\r\n            if (requestTimerEventBeforeFirstFrame) {\r\n              _clearTimeout(idleTimeoutID);\r\n            }\r\n            frameDeadline = exports.unstable_now() + frameLength;\r\n            performWorkUntilDeadline();\r\n          });\r\n        }\r\n        // Alternate strategy to address the same problem. Scheduler a timer\r\n        // with no delay. If this fires before the rAF, that likely indicates\r\n        // that there's idle time before the next vsync. This isn't always the\r\n        // case, but we'll be aggressive and assume it is, as a trade off to\r\n        // prevent idle periods.\r\n        var idleTimeoutID = void 0;\r\n        if (requestTimerEventBeforeFirstFrame) {\r\n          idleTimeoutID = _setTimeout(function onTimerEventBeforeFirstFrame() {\r\n            if (requestIdleCallbackBeforeFirstFrame$1) {\r\n              cancelIdleCallback(idleCallbackID);\r\n            }\r\n            frameDeadline = exports.unstable_now() + frameLength;\r\n            performWorkUntilDeadline();\r\n          }, 0);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  requestHostTimeout = function (callback, ms) {\r\n    taskTimeoutID = _setTimeout(function () {\r\n      callback(exports.unstable_now());\r\n    }, ms);\r\n  };\r\n\r\n  cancelHostTimeout = function () {\r\n    _clearTimeout(taskTimeoutID);\r\n    taskTimeoutID = -1;\r\n  };\r\n}\r\n\r\n/* eslint-disable no-var */\r\n\r\n// TODO: Use symbols?\r\nvar ImmediatePriority = 1;\r\nvar UserBlockingPriority = 2;\r\nvar NormalPriority = 3;\r\nvar LowPriority = 4;\r\nvar IdlePriority = 5;\r\n\r\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\r\n// Math.pow(2, 30) - 1\r\n// 0b111111111111111111111111111111\r\nvar maxSigned31BitInt = 1073741823;\r\n\r\n// Times out immediately\r\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\r\n// Eventually times out\r\nvar USER_BLOCKING_PRIORITY = 250;\r\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\r\nvar LOW_PRIORITY_TIMEOUT = 10000;\r\n// Never times out\r\nvar IDLE_PRIORITY = maxSigned31BitInt;\r\n\r\n// Tasks are stored as a circular, doubly linked list.\r\nvar firstTask = null;\r\nvar firstDelayedTask = null;\r\n\r\n// Pausing the scheduler is useful for debugging.\r\nvar isSchedulerPaused = false;\r\n\r\nvar currentTask = null;\r\nvar currentPriorityLevel = NormalPriority;\r\n\r\n// This is set while performing work, to prevent re-entrancy.\r\nvar isPerformingWork = false;\r\n\r\nvar isHostCallbackScheduled = false;\r\nvar isHostTimeoutScheduled = false;\r\n\r\nfunction scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\nfunction scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\nfunction scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\nfunction scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\nfunction scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\n\r\nfunction flushTask(task, currentTime) {\r\n  // Remove the task from the list before calling the callback. That way the\r\n  // list is in a consistent state even if the callback throws.\r\n  var next = task.next;\r\n  if (next === task) {\r\n    // This is the only scheduled task. Clear the list.\r\n    firstTask = null;\r\n  } else {\r\n    // Remove the task from its position in the list.\r\n    if (task === firstTask) {\r\n      firstTask = next;\r\n    }\r\n    var previous = task.previous;\r\n    previous.next = next;\r\n    next.previous = previous;\r\n  }\r\n  task.next = task.previous = null;\r\n\r\n  // Now it's safe to execute the task.\r\n  var callback = task.callback;\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  var previousTask = currentTask;\r\n  currentPriorityLevel = task.priorityLevel;\r\n  currentTask = task;\r\n  var continuationCallback;\r\n  try {\r\n    var didUserCallbackTimeout = task.expirationTime <= currentTime;\r\n    // Add an extra function to the callstack. Profiling tools can use this\r\n    // to infer the priority of work that appears higher in the stack.\r\n    switch (currentPriorityLevel) {\r\n      case ImmediatePriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\r\n        break;\r\n      case UserBlockingPriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\r\n        break;\r\n      case NormalPriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\r\n        break;\r\n      case LowPriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\r\n        break;\r\n      case IdlePriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\r\n        break;\r\n    }\r\n  } catch (error) {\r\n    throw error;\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    currentTask = previousTask;\r\n  }\r\n\r\n  // A callback may return a continuation. The continuation should be scheduled\r\n  // with the same priority and expiration as the just-finished callback.\r\n  if (typeof continuationCallback === 'function') {\r\n    var expirationTime = task.expirationTime;\r\n    var continuationTask = task;\r\n    continuationTask.callback = continuationCallback;\r\n\r\n    // Insert the new callback into the list, sorted by its timeout. This is\r\n    // almost the same as the code in `scheduleCallback`, except the callback\r\n    // is inserted into the list *before* callbacks of equal timeout instead\r\n    // of after.\r\n    if (firstTask === null) {\r\n      // This is the first callback in the list.\r\n      firstTask = continuationTask.next = continuationTask.previous = continuationTask;\r\n    } else {\r\n      var nextAfterContinuation = null;\r\n      var t = firstTask;\r\n      do {\r\n        if (expirationTime <= t.expirationTime) {\r\n          // This task times out at or after the continuation. We will insert\r\n          // the continuation *before* this task.\r\n          nextAfterContinuation = t;\r\n          break;\r\n        }\r\n        t = t.next;\r\n      } while (t !== firstTask);\r\n      if (nextAfterContinuation === null) {\r\n        // No equal or lower priority task was found, which means the new task\r\n        // is the lowest priority task in the list.\r\n        nextAfterContinuation = firstTask;\r\n      } else if (nextAfterContinuation === firstTask) {\r\n        // The new task is the highest priority task in the list.\r\n        firstTask = continuationTask;\r\n      }\r\n\r\n      var _previous = nextAfterContinuation.previous;\r\n      _previous.next = nextAfterContinuation.previous = continuationTask;\r\n      continuationTask.next = nextAfterContinuation;\r\n      continuationTask.previous = _previous;\r\n    }\r\n  }\r\n}\r\n\r\nfunction advanceTimers(currentTime) {\r\n  // Check for tasks that are no longer delayed and add them to the queue.\r\n  if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\r\n    do {\r\n      var task = firstDelayedTask;\r\n      var next = task.next;\r\n      if (task === next) {\r\n        firstDelayedTask = null;\r\n      } else {\r\n        firstDelayedTask = next;\r\n        var previous = task.previous;\r\n        previous.next = next;\r\n        next.previous = previous;\r\n      }\r\n      task.next = task.previous = null;\r\n      insertScheduledTask(task, task.expirationTime);\r\n    } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\r\n  }\r\n}\r\n\r\nfunction handleTimeout(currentTime) {\r\n  isHostTimeoutScheduled = false;\r\n  advanceTimers(currentTime);\r\n\r\n  if (!isHostCallbackScheduled) {\r\n    if (firstTask !== null) {\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    } else if (firstDelayedTask !== null) {\r\n      requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWork(hasTimeRemaining, initialTime) {\r\n  // Exit right away if we're currently paused\r\n  if (enableSchedulerDebugging && isSchedulerPaused) {\r\n    return;\r\n  }\r\n\r\n  // We'll need a host callback the next time work is scheduled.\r\n  isHostCallbackScheduled = false;\r\n  if (isHostTimeoutScheduled) {\r\n    // We scheduled a timeout but it's no longer needed. Cancel it.\r\n    isHostTimeoutScheduled = false;\r\n    cancelHostTimeout();\r\n  }\r\n\r\n  var currentTime = initialTime;\r\n  advanceTimers(currentTime);\r\n\r\n  isPerformingWork = true;\r\n  try {\r\n    if (!hasTimeRemaining) {\r\n      // Flush all the expired callbacks without yielding.\r\n      // TODO: Split flushWork into two separate functions instead of using\r\n      // a boolean argument?\r\n      while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\r\n        flushTask(firstTask, currentTime);\r\n        currentTime = exports.unstable_now();\r\n        advanceTimers(currentTime);\r\n      }\r\n    } else {\r\n      // Keep flushing callbacks until we run out of time in the frame.\r\n      if (firstTask !== null) {\r\n        do {\r\n          flushTask(firstTask, currentTime);\r\n          currentTime = exports.unstable_now();\r\n          advanceTimers(currentTime);\r\n        } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\r\n      }\r\n    }\r\n    // Return whether there's additional work\r\n    if (firstTask !== null) {\r\n      return true;\r\n    } else {\r\n      if (firstDelayedTask !== null) {\r\n        requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\r\n      }\r\n      return false;\r\n    }\r\n  } finally {\r\n    isPerformingWork = false;\r\n  }\r\n}\r\n\r\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n    case LowPriority:\r\n    case IdlePriority:\r\n      break;\r\n    default:\r\n      priorityLevel = NormalPriority;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  currentPriorityLevel = priorityLevel;\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n  }\r\n}\r\n\r\nfunction unstable_next(eventHandler) {\r\n  var priorityLevel;\r\n  switch (currentPriorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n      // Shift down to normal priority\r\n      priorityLevel = NormalPriority;\r\n      break;\r\n    default:\r\n      // Anything lower than normal priority should remain at the current level.\r\n      priorityLevel = currentPriorityLevel;\r\n      break;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  currentPriorityLevel = priorityLevel;\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n  }\r\n}\r\n\r\nfunction unstable_wrapCallback(callback) {\r\n  var parentPriorityLevel = currentPriorityLevel;\r\n  return function () {\r\n    // This is a fork of runWithPriority, inlined for performance.\r\n    var previousPriorityLevel = currentPriorityLevel;\r\n    currentPriorityLevel = parentPriorityLevel;\r\n\r\n    try {\r\n      return callback.apply(this, arguments);\r\n    } finally {\r\n      currentPriorityLevel = previousPriorityLevel;\r\n    }\r\n  };\r\n}\r\n\r\nfunction timeoutForPriorityLevel(priorityLevel) {\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n      return IMMEDIATE_PRIORITY_TIMEOUT;\r\n    case UserBlockingPriority:\r\n      return USER_BLOCKING_PRIORITY;\r\n    case IdlePriority:\r\n      return IDLE_PRIORITY;\r\n    case LowPriority:\r\n      return LOW_PRIORITY_TIMEOUT;\r\n    case NormalPriority:\r\n    default:\r\n      return NORMAL_PRIORITY_TIMEOUT;\r\n  }\r\n}\r\n\r\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\r\n  var currentTime = exports.unstable_now();\r\n\r\n  var startTime;\r\n  var timeout;\r\n  if (typeof options === 'object' && options !== null) {\r\n    var delay = options.delay;\r\n    if (typeof delay === 'number' && delay > 0) {\r\n      startTime = currentTime + delay;\r\n    } else {\r\n      startTime = currentTime;\r\n    }\r\n    timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\r\n  } else {\r\n    timeout = timeoutForPriorityLevel(priorityLevel);\r\n    startTime = currentTime;\r\n  }\r\n\r\n  var expirationTime = startTime + timeout;\r\n\r\n  var newTask = {\r\n    callback: callback,\r\n    priorityLevel: priorityLevel,\r\n    startTime: startTime,\r\n    expirationTime: expirationTime,\r\n    next: null,\r\n    previous: null\r\n  };\r\n\r\n  if (startTime > currentTime) {\r\n    // This is a delayed task.\r\n    insertDelayedTask(newTask, startTime);\r\n    if (firstTask === null && firstDelayedTask === newTask) {\r\n      // All tasks are delayed, and this is the task with the earliest delay.\r\n      if (isHostTimeoutScheduled) {\r\n        // Cancel an existing timeout.\r\n        cancelHostTimeout();\r\n      } else {\r\n        isHostTimeoutScheduled = true;\r\n      }\r\n      // Schedule a timeout.\r\n      requestHostTimeout(handleTimeout, startTime - currentTime);\r\n    }\r\n  } else {\r\n    insertScheduledTask(newTask, expirationTime);\r\n    // Schedule a host callback, if needed. If we're already performing work,\r\n    // wait until the next time we yield.\r\n    if (!isHostCallbackScheduled && !isPerformingWork) {\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    }\r\n  }\r\n\r\n  return newTask;\r\n}\r\n\r\nfunction insertScheduledTask(newTask, expirationTime) {\r\n  // Insert the new task into the list, ordered first by its timeout, then by\r\n  // insertion. So the new task is inserted after any other task the\r\n  // same timeout\r\n  if (firstTask === null) {\r\n    // This is the first task in the list.\r\n    firstTask = newTask.next = newTask.previous = newTask;\r\n  } else {\r\n    var next = null;\r\n    var task = firstTask;\r\n    do {\r\n      if (expirationTime < task.expirationTime) {\r\n        // The new task times out before this one.\r\n        next = task;\r\n        break;\r\n      }\r\n      task = task.next;\r\n    } while (task !== firstTask);\r\n\r\n    if (next === null) {\r\n      // No task with a later timeout was found, which means the new task has\r\n      // the latest timeout in the list.\r\n      next = firstTask;\r\n    } else if (next === firstTask) {\r\n      // The new task has the earliest expiration in the entire list.\r\n      firstTask = newTask;\r\n    }\r\n\r\n    var previous = next.previous;\r\n    previous.next = next.previous = newTask;\r\n    newTask.next = next;\r\n    newTask.previous = previous;\r\n  }\r\n}\r\n\r\nfunction insertDelayedTask(newTask, startTime) {\r\n  // Insert the new task into the list, ordered by its start time.\r\n  if (firstDelayedTask === null) {\r\n    // This is the first task in the list.\r\n    firstDelayedTask = newTask.next = newTask.previous = newTask;\r\n  } else {\r\n    var next = null;\r\n    var task = firstDelayedTask;\r\n    do {\r\n      if (startTime < task.startTime) {\r\n        // The new task times out before this one.\r\n        next = task;\r\n        break;\r\n      }\r\n      task = task.next;\r\n    } while (task !== firstDelayedTask);\r\n\r\n    if (next === null) {\r\n      // No task with a later timeout was found, which means the new task has\r\n      // the latest timeout in the list.\r\n      next = firstDelayedTask;\r\n    } else if (next === firstDelayedTask) {\r\n      // The new task has the earliest expiration in the entire list.\r\n      firstDelayedTask = newTask;\r\n    }\r\n\r\n    var previous = next.previous;\r\n    previous.next = next.previous = newTask;\r\n    newTask.next = next;\r\n    newTask.previous = previous;\r\n  }\r\n}\r\n\r\nfunction unstable_pauseExecution() {\r\n  isSchedulerPaused = true;\r\n}\r\n\r\nfunction unstable_continueExecution() {\r\n  isSchedulerPaused = false;\r\n  if (!isHostCallbackScheduled && !isPerformingWork) {\r\n    isHostCallbackScheduled = true;\r\n    requestHostCallback(flushWork);\r\n  }\r\n}\r\n\r\nfunction unstable_getFirstCallbackNode() {\r\n  return firstTask;\r\n}\r\n\r\nfunction unstable_cancelCallback(task) {\r\n  var next = task.next;\r\n  if (next === null) {\r\n    // Already cancelled.\r\n    return;\r\n  }\r\n\r\n  if (task === next) {\r\n    if (task === firstTask) {\r\n      firstTask = null;\r\n    } else if (task === firstDelayedTask) {\r\n      firstDelayedTask = null;\r\n    }\r\n  } else {\r\n    if (task === firstTask) {\r\n      firstTask = next;\r\n    } else if (task === firstDelayedTask) {\r\n      firstDelayedTask = next;\r\n    }\r\n    var previous = task.previous;\r\n    previous.next = next;\r\n    next.previous = previous;\r\n  }\r\n\r\n  task.next = task.previous = null;\r\n}\r\n\r\nfunction unstable_getCurrentPriorityLevel() {\r\n  return currentPriorityLevel;\r\n}\r\n\r\nfunction unstable_shouldYield() {\r\n  var currentTime = exports.unstable_now();\r\n  advanceTimers(currentTime);\r\n  return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\r\n}\r\n\r\nvar unstable_requestPaint = requestPaint;\r\n\r\nexports.unstable_ImmediatePriority = ImmediatePriority;\r\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\r\nexports.unstable_NormalPriority = NormalPriority;\r\nexports.unstable_IdlePriority = IdlePriority;\r\nexports.unstable_LowPriority = LowPriority;\r\nexports.unstable_runWithPriority = unstable_runWithPriority;\r\nexports.unstable_next = unstable_next;\r\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\r\nexports.unstable_cancelCallback = unstable_cancelCallback;\r\nexports.unstable_wrapCallback = unstable_wrapCallback;\r\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\r\nexports.unstable_shouldYield = unstable_shouldYield;\r\nexports.unstable_requestPaint = unstable_requestPaint;\r\nexports.unstable_continueExecution = unstable_continueExecution;\r\nexports.unstable_pauseExecution = unstable_pauseExecution;\r\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\r\n  })();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}